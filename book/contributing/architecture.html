<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Architecture - wgsl-analyzer</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">wgsl-analyzer</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/wgsl-analyzer/wgsl-analyzer/tree/master/docs/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/wgsl-analyzer/wgsl-analyzer/edit/master/docs/book/src/contributing/architecture.md" title="Suggest an edit" aria-label="Suggest an edit" rel="edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="architecture"><a class="header" href="#architecture">Architecture</a></h1>
<p>This document describes the high-level architecture of wgsl-analyzer.
If you want to familiarize yourself with the code base, you are just in the right place!</p>
<p>Since <code>wgsl-analyzer</code> is largely copied from <a href="https://github.com/rust-lang/rust-analyzer"><code>rust-analyzer</code></a>, you might also enjoy the <a href="https://www.youtube.com/playlist?list=PLhb66M_x9UmrqXhQuIpWC5VgTdrGxMx3y">Explaining Rust Analyzer</a> series on YouTube.
It goes deeper than what is covered in this document, but will take some time to watch.</p>
<p>See also these implementation-related blog posts:</p>
<ul>
<li><a href="https://rust-analyzer.github.io/blog/2019/11/13/find-usages.html">https://rust-analyzer.github.io/blog/2019/11/13/find-usages.html</a></li>
<li><a href="https://rust-analyzer.github.io/blog/2020/07/20/three-architectures-for-responsive-ide.html">https://rust-analyzer.github.io/blog/2020/07/20/three-architectures-for-responsive-ide.html</a></li>
<li><a href="https://rust-analyzer.github.io/blog/2020/09/16/challeging-LR-parsing.html">https://rust-analyzer.github.io/blog/2020/09/16/challeging-LR-parsing.html</a></li>
<li><a href="https://rust-analyzer.github.io/blog/2020/09/28/how-to-make-a-light-bulb.html">https://rust-analyzer.github.io/blog/2020/09/28/how-to-make-a-light-bulb.html</a></li>
<li><a href="https://rust-analyzer.github.io/blog/2020/10/24/introducing-ungrammar.html">https://rust-analyzer.github.io/blog/2020/10/24/introducing-ungrammar.html</a></li>
</ul>
<p>For older, by now mostly outdated stuff, see the <a href="./guide.html">guide</a> and <a href="https://www.youtube.com/playlist?list=PL85XCvVPmGQho7MZkdW-wtPtuJcFpzycE">another playlist</a>.</p>
<h2 id="birds-eye-view"><a class="header" href="#birds-eye-view">Bird's Eye View</a></h2>
<p><img src="https://user-images.githubusercontent.com/4789492/107129398-0ab70f00-687a-11eb-9bfc-d4eb023aec06.png" alt="Bird&#39;s Eye View diagram" /></p>
<ul>
<li><a href="#entry-points">Entry Points</a></li>
<li><a href="#code-map">Code Map</a>
<ul>
<li><a href="#xtask"><code>xtask</code></a></li>
<li><a href="#editorscode"><code>editors/code</code></a></li>
<li><a href="#lib"><code>lib</code></a></li>
<li><a href="#cratesparser"><code>crates/parser</code></a></li>
<li><a href="#cratessyntax"><code>crates/syntax</code></a></li>
<li><a href="#cratesbase-db"><code>crates/base-db</code></a></li>
<li><a href="#crateshir-def-crateshir_ty"><code>crates/hir-def</code>, <code>crates/hir_ty</code></a></li>
<li><a href="#crateshir"><code>crates/hir</code></a></li>
<li><a href="#crateside-crateside-db-crateside-assists-crateside-completion-crateside-diagnostics-crateside-ssr"><code>crates/ide</code>, <code>crates/ide-db</code>, <code>crates/ide-assists</code>, <code>crates/ide-completion</code>, <code>crates/ide-diagnostics</code>, <code>crates/ide-ssr</code></a></li>
<li><a href="#crateswgsl-analyzer"><code>crates/wgsl-analyzer</code></a></li>
<li><a href="#cratestoolchain-cratesproject-model-cratesflycheck"><code>crates/toolchain</code>, <code>crates/project-model</code>, <code>crates/flycheck</code></a></li>
<li><a href="#cratescfg"><code>crates/cfg</code></a></li>
<li><a href="#cratesvfs-cratesvfs-notify-cratespaths"><code>crates/vfs</code>, <code>crates/vfs-notify</code>, <code>crates/paths</code></a></li>
<li><a href="#cratesstdx"><code>crates/stdx</code></a></li>
<li><a href="#cratesprofile"><code>crates/profile</code></a></li>
<li><a href="#cratesspan"><code>crates/span</code></a></li>
</ul>
</li>
<li><a href="#cross-cutting-concerns">Cross-Cutting Concerns</a>
<ul>
<li><a href="#stability-guarantees">Stability Guarantees</a></li>
<li><a href="#code-generation">Code generation</a></li>
<li><a href="#cancellation">Cancellation</a></li>
<li><a href="#testing">Testing</a></li>
<li><a href="#performance-testing">Performance Testing</a></li>
<li><a href="#error-handling">Error Handling</a></li>
<li><a href="#observability">Observability</a></li>
<li><a href="#configurability">Configurability</a></li>
</ul>
</li>
</ul>
<p>On the highest level, <code>wgsl-analyzer</code> is a thing which accepts input source code from the client and produces a structured semantic model of the code.</p>
<p>More specifically, input data consists of a set of test files (<code>(PathBuf, String)</code> pairs) and information about project structure, captured in the so-called <code>CrateGraph</code>.
The crate graph specifies which files are crate roots, which cfg flags are specified for each crate, and what dependencies exist between the crates.
This is the input (ground) state.
The analyzer keeps all this input data in memory and never does any IO.
Because the input data is source code, which typically measures in tens of megabytes at most, keeping everything in memory is OK.</p>
<p>A "structured semantic model" is basically an object-oriented representation of modules, functions, and types which appear in the source code.
This representation is fully "resolved": all expressions have types, all references are bound to declarations, etc.
This is derived state.</p>
<p>The client can submit a small delta of input data (typically, a change to a single file) and get a fresh code model which accounts for changes.</p>
<p>The underlying engine makes sure that the model is computed lazily (on-demand) and can be quickly updated for small modifications.</p>
<h2 id="entry-points"><a class="header" href="#entry-points">Entry Points</a></h2>
<p><code>crates/wgsl-analyzer/src/bin/main.rs</code> contains the main function which spawns LSP.
This is <em>the</em> entry point, but it front-loads a lot of complexity, so it is fine to just skim through it.</p>
<p><code>crates/wgsl-analyzer/src/handlers/request.rs</code> implements all LSP requests and is a great place to start if you are already familiar with LSP.</p>
<p><code>Analysis</code> and <code>AnalysisHost</code> types define the main API for consumers of IDE services.</p>
<h2 id="code-map"><a class="header" href="#code-map">Code Map</a></h2>
<p>This section talks briefly about various important directories and data structures.
Pay attention to the <strong>Architecture Invariant</strong> sections.
They often talk about things which are deliberately absent in the source code.</p>
<p>Note also which crates are <strong>API Boundaries</strong>.
Remember, <a href="https://www.tedinski.com/2018/02/06/system-boundaries.html">rules at the boundary are different</a>.</p>
<h3 id="xtask"><a class="header" href="#xtask"><code>xtask</code></a></h3>
<p>This is <code>wgsl-analyzer</code>'s "build system".
We use <a href="https://github.com/rust-lang/cargo"><code>cargo</code></a> to compile Rust code, but there are also various other tasks, such as release management or local installation.
Those are handled by Rust code in the <code>xtask</code> directory.</p>
<h3 id="editorscode"><a class="header" href="#editorscode"><code>editors/code</code></a></h3>
<p>The VS Code extension.</p>
<h3 id="lib"><a class="header" href="#lib"><code>lib</code></a></h3>
<p><code>wgsl-analyzer</code>-independent libraries which we publish to crates.io.
It is not heavily utilized at the moment.</p>
<h3 id="cratesparser"><a class="header" href="#cratesparser"><code>crates/parser</code></a></h3>
<!-- TODO
It is a hand-written recursive descent parser, which produces a sequence of events like "start node X", "finish node Y".
It works similarly to
[kotlin's parser](https://github.com/JetBrains/kotlin/blob/4d951de616b20feca92f3e9cc9679b2de9e65195/compiler/frontend/src/org/jetbrains/kotlin/parsing/KotlinParsing.java),
which is a good source of inspiration for dealing with syntax errors and incomplete input.
Original [libsyntax parser](https://github.com/Rust-lang/Rust/blob/6b99adeb11313197f409b4f7c4083c2ceca8a4fe/src/libsyntax/parse/parser.rs) is what we use for the definition of the Rust language.
`TreeSink` and `TokenSource` traits bridge the tree-agnostic parser from `grammar` with `rowan` trees.
-->
<p><strong>Architecture Invariant:</strong> the parser is independent of the particular tree structure and particular representation of the tokens.
It transforms one flat stream of events into another flat stream of events.
Token independence allows us to parse out both text-based source code and <code>tt</code>-based macro input.
Tree independence allows us to more easily vary the syntax tree implementation.
It should also unlock efficient light-parsing approaches.
For example, you can extract the set of names defined in a file (for typo correction) without building a syntax tree.</p>
<p><strong>Architecture Invariant:</strong> parsing never fails, the parser produces <code>(T, Vec&lt;Error&gt;)</code> rather than <code>Result&lt;T, Error&gt;</code>.</p>
<h3 id="cratessyntax"><a class="header" href="#cratessyntax"><code>crates/syntax</code></a></h3>
<p>WESL syntax tree structure and parser.</p>
<!-- https://github.com/gpuweb/gpuweb/tree/main/design -->
<p>See <a href="https://github.com/rust-lang/rfcs/pull/2256">RFC</a> and <a href="./syntax.html">./syntax.md</a> for some design notes.</p>
<ul>
<li><a href="https://github.com/rust-analyzer/rowan"><code>rowan</code></a> library is used for constructing syntax trees.</li>
<li><code>ast</code> provides a type safe API on top of the raw <code>rowan</code> tree.</li>
<li><code>ungrammar</code> description of the grammar, which is used to generate <code>syntax_kinds</code> and <code>ast</code> modules, using <code>cargo test -p xtask</code> command.</li>
</ul>
<p>Tests for wa_syntax are mostly data-driven.
<code>test_data/parser</code> contains subdirectories with a bunch of <code>.rs</code> (test vectors) and <code>.txt</code> files with corresponding syntax trees.
During testing, we check <code>.rs</code> against <code>.txt</code>.
If the <code>.txt</code> file is missing, it is created (this is how you update tests).
Additionally, running the xtask test suite with <code>cargo test -p xtask</code> will walk the grammar module and collect all <code>// test test_name</code> comments into files inside <code>test_data/parser/inline</code> directory.</p>
<p>To update test data, run with <code>UPDATE_EXPECT</code> variable:</p>
<pre><code class="language-bash">env UPDATE_EXPECT=1 cargo qt
</code></pre>
<p>After adding a new inline test you need to run <code>cargo test -p xtask</code> and also update the test data as described above.</p>
<p>Note <a href="https://github.com/wgsl-analyzer/wgsl-analyzer/tree/main/crates/syntax/src/lib.rs#L252"><code>api_walkthrough</code></a>
in particular: it shows off various methods of working with syntax tree.</p>
<!-- TODO put a wgsl-analyzer PR here -->
<p>See <a href="https://github.com/wgsl-analyzer/wgsl-analyzer/pull/TODO">#TODO</a> for an example PR which fixes a bug in the grammar.</p>
<p><strong>Architecture Invariant:</strong> <code>syntax</code> crate is completely independent from the rest of wgsl-analyzer.
It knows nothing about salsa or LSP.
This is important because it is possible to make useful tooling using only the syntax tree.
Without semantic information, you do not need to be able to <em>build</em> code, which makes the tooling more robust.
See also <a href="https://mlfbrown.com/paper.pdf">https://mlfbrown.com/paper.pdf</a>.
You can view the <code>syntax</code> crate as an entry point to wgsl-analyzer.
<code>syntax</code> crate is an <strong>API Boundary</strong>.</p>
<p><strong>Architecture Invariant:</strong> syntax tree is a value type.
The tree is fully determined by the contents of its syntax nodes, it does not need global context (like an interner) and does not store semantic info.
Using the tree as a store for semantic info is convenient in traditional compilers, but does not work nicely in the IDE.
Specifically, assists, and refactors require transforming syntax trees, and that becomes awkward if you need to do something with the semantic info.</p>
<p><strong>Architecture Invariant:</strong> syntax tree is built for a single file.
This is to enable parallel parsing of all files.</p>
<p><strong>Architecture Invariant:</strong>  Syntax trees are by design incomplete and do not enforce well-formedness.
If an AST method returns an <code>Option</code>, it <em>can</em> be <code>None</code> at runtime, even if this is forbidden by the grammar.</p>
<h3 id="cratesbase-db"><a class="header" href="#cratesbase-db"><code>crates/base-db</code></a></h3>
<p>We use the <a href="https://github.com/salsa-rs/salsa">salsa</a> crate for incremental and on-demand computation.
Roughly, you can think of salsa as a key-value store, but it can also compute derived values using specified functions.
The <code>base-db</code> crate provides basic infrastructure for interacting with salsa.
Crucially, it defines most of the "input" queries: facts supplied by the client of the analyzer.
Reading the docs of the <code>base_db::input</code> module should be useful: everything else is strictly derived from those inputs.</p>
<p><strong>Architecture Invariant:</strong> particularities of the build system are <em>not</em> the part of the ground state.
In particular, <code>base-db</code> knows nothing about cargo.
For example, <code>cfg</code> flags are a part of <code>base_db</code>, but <code>feature</code>s are not.
A <code>foo</code> feature is a Cargo-level concept, which is lowered by Cargo to <code>--cfg feature=foo</code> argument on the command line.
The <code>CrateGraph</code> structure is used to represent the dependencies between the crates abstractly.</p>
<p><strong>Architecture Invariant:</strong> <code>base-db</code> does not know about file system and file paths.
Files are represented with opaque <code>FileId</code>, there is no operation to get an <code>std::path::Path</code> out of the <code>FileId</code>.</p>
<h3 id="crateshir-def-crateshir_ty"><a class="header" href="#crateshir-def-crateshir_ty"><code>crates/hir-def</code>, <code>crates/hir_ty</code></a></h3>
<p>These crates are the <em>brain</em> of wgsl-analyzer.
This is the compiler part of the IDE.</p>
<p><code>hir-xxx</code> crates have a strong <a href="https://en.wikipedia.org/wiki/Entity_component_system">ECS</a> flavor, in that they work with raw ids and directly query the database.
There is very little abstraction here.
These crates integrate deeply with salsa and chalk.</p>
<p>Name resolution and type inference all happen here.
These crates also define various intermediate representations of the core.</p>
<p><code>ItemTree</code> condenses a single <code>SyntaxTree</code> into a "summary" data structure, which is stable over modifications to function bodies.</p>
<p><code>DefMap</code> contains the module tree of a crate and stores module scopes.</p>
<p><code>Body</code> stores information about expressions.</p>
<p><strong>Architecture Invariant:</strong> these crates are not, and will never be, an api boundary.</p>
<p><strong>Architecture Invariant:</strong> these crates explicitly care about being incremental.
The core invariant we maintain is "typing inside a function's body never invalidates global derived data".
i.e., if you change the body of <code>foo</code>, all facts about <code>bar</code> should remain intact.</p>
<p><strong>Architecture Invariant:</strong> hir exists only in context of particular crate instance with specific CFG flags.
The same syntax may produce several instances of HIR if the crate participates in the crate graph more than once.</p>
<h3 id="crateshir"><a class="header" href="#crateshir"><code>crates/hir</code></a></h3>
<p>The top-level <code>hir</code> crate is an <strong>API Boundary</strong>.
If you think about "using wgsl-analyzer as a library", <code>hir</code> crate is most likely the interface that you will be talking to.</p>
<p>It wraps ECS-style internal API into a more OO-flavored API (with an extra <code>db</code> argument for each call).</p>
<p><strong>Architecture Invariant:</strong> <code>hir</code> provides a static, fully resolved view of the code.
While internal <code>hir-*</code> crates <em>compute</em> things, <code>hir</code>, from the outside, looks like an inert data structure.</p>
<p><code>hir</code> also handles the delicate task of going from syntax to the corresponding <code>hir</code>.
Remember that the mapping here is one-to-many.
See <code>Semantics</code> type and <code>source_to_def</code> module.</p>
<p>Note in particular a curious recursive structure in <code>source_to_def</code>.
We first resolve the parent <em>syntax</em> node to the parent <em>hir</em> element.
Then we ask the <em>hir</em> parent what <em>syntax</em> children does it have.
Then we look for our node in the set of children.</p>
<p>This is the heart of many IDE features, like goto definition, which start with figuring out the hir node at the cursor.
This is some kind of (yet unnamed) uber-IDE pattern, as it is present in Roslyn and Kotlin as well.</p>
<!-- markdownlint-disable line-length -->
<h3 id="crateside-crateside-db-crateside-assists-crateside-completion-crateside-diagnostics-crateside-ssr"><a class="header" href="#crateside-crateside-db-crateside-assists-crateside-completion-crateside-diagnostics-crateside-ssr"><code>crates/ide</code>, <code>crates/ide-db</code>, <code>crates/ide-assists</code>, <code>crates/ide-completion</code>, <code>crates/ide-diagnostics</code>, <code>crates/ide-ssr</code></a></h3>
<!-- markdownlint-restore line-length -->
<p>The <code>ide</code> crate builds on top of <code>hir</code> semantic model to provide high-level IDE features like completion or goto definition.
It is an <strong>API Boundary</strong>.
If you want to use IDE parts of <code>wgsl-analyzer</code> via LSP, custom flatbuffers-based protocol or just as a library in your text editor, this is the right API.</p>
<p><strong>Architecture Invariant:</strong> <code>ide</code> crate's API is build out of POD types with public fields.
The API uses editor's terminology, it talks about offsets and string labels rather than in terms of definitions or types.
It is effectively the view in MVC and viewmodel in <a href="https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93viewmodel">MVVM</a>.
All arguments and return types are conceptually serializable.
In particular, syntax trees and hir types are generally absent from the API (but are used heavily in the implementation).
Shout outs to LSP developers for popularizing the idea that "UI" is a good place to draw a boundary at.</p>
<p><code>ide</code> is also the first crate which has the notion of change over time.
<code>AnalysisHost</code> is a state to which you can transactionally <code>apply_change</code>.
<code>Analysis</code> is an immutable snapshot of the state.</p>
<p>Internally, <code>ide</code> is split across several crates.
<code>ide-assists</code>, <code>ide-completion</code>, <code>ide-diagnostics</code> and <code>ide-ssr</code> implement large isolated features.
<code>ide-db</code> implements common IDE functionality (notably, reference search is implemented here).
The <code>ide</code> contains a public API, as well as implementation for a plethora of smaller features.</p>
<p><strong>Architecture Invariant:</strong> <code>ide</code> crate strives to provide a <em>perfect</em> API.
Although at the moment it has only one consumer, the LSP server, LSP <em>does not</em> influence its API design.
Instead, we keep in mind a hypothetical <em>ideal</em> client - an IDE tailored specifically for WGSL and WESL, every nook and cranny of which is packed with language-specific goodies.</p>
<h3 id="crateswgsl-analyzer"><a class="header" href="#crateswgsl-analyzer"><code>crates/wgsl-analyzer</code></a></h3>
<p>This crate defines the <code>wgsl-analyzer</code> binary, so it is the <strong>entry point</strong>.
It implements the language server.</p>
<p><strong>Architecture Invariant:</strong> <code>wgsl-analyzer</code> is the only crate that knows about LSP and JSON serialization.
If you want to expose a data structure <code>X</code> from ide to LSP, do not make it serializable.
Instead, create a serializable counterpart in <code>wgsl-analyzer</code> crate and manually convert between the two.</p>
<p><code>GlobalState</code> is the state of the server.
The <code>main_loop</code> defines the server event loop, which accepts requests and sends responses.
Requests that modify the state or might block a user's typing are handled on the main thread.
All other requests are processed in background.</p>
<p><strong>Architecture Invariant:</strong> the server is stateless, a-la HTTP.
Sometimes state needs to be preserved between requests.
For example, "what is the <code>edit</code> for the fifth completion item of the last completion edit?".
For this, the second request should include enough info to re-create the context from scratch.
This generally means including all the parameters of the original request.</p>
<p><code>reload</code> module contains the code that handles configuration and Cargo.toml changes.
This is a tricky business.</p>
<p><strong>Architecture Invariant:</strong> <code>wgsl-analyzer</code> should be partially available even when the build is broken.
Reloading process should not prevent IDE features from working.</p>
<h3 id="cratestoolchain-cratesproject-model-cratesflycheck"><a class="header" href="#cratestoolchain-cratesproject-model-cratesflycheck"><code>crates/toolchain</code>, <code>crates/project-model</code>, <code>crates/flycheck</code></a></h3>
<p>These crates deal with invoking <code>cargo</code> to learn about project structure and get compiler errors for the "check on save" feature.</p>
<p>They use <code>crates/paths</code> heavily instead of <code>std::path</code>.
A single <code>wgsl-analyzer</code> process can serve many projects, so it is important that the server's current working directory does not leak.</p>
<h3 id="cratescfg"><a class="header" href="#cratescfg"><code>crates/cfg</code></a></h3>
<p>This crate is responsible for parsing, evaluation, and general definition of <code>cfg</code> attributes.</p>
<h3 id="cratesvfs-cratesvfs-notify-cratespaths"><a class="header" href="#cratesvfs-cratesvfs-notify-cratespaths"><code>crates/vfs</code>, <code>crates/vfs-notify</code>, <code>crates/paths</code></a></h3>
<p>These crates implement a virtual file system.
They provide consistent snapshots of the underlying file system and insulate messy OS paths.</p>
<p><strong>Architecture Invariant:</strong> vfs does not assume a single unified file system.
i.e., a single <code>wgsl-analyzer</code> process can act as a remote server for two different machines, where the same <code>/tmp/foo.rs</code> path points to different files.
For this reason, all path APIs generally take some existing path as a "file system witness".</p>
<h3 id="cratesstdx"><a class="header" href="#cratesstdx"><code>crates/stdx</code></a></h3>
<p>This crate contains various non-wgsl-analyzer specific utils, which could have been in std, as well
as copies of unstable std items we would like to make use of already, like <code>std::str::split_once</code>.</p>
<h3 id="cratesprofile"><a class="header" href="#cratesprofile"><code>crates/profile</code></a></h3>
<p>This crate contains utilities for CPU and memory profiling.</p>
<!--
TODO: See https://github.com/wgsl-analyzer/wgsl-analyzer/issues/361
### `crates/intern`

This crate contains infrastructure for globally interning things via `Arc`.
-->
<h3 id="cratesspan"><a class="header" href="#cratesspan"><code>crates/span</code></a></h3>
<p>This crate exposes types and functions related to <code>wgsl-analyzer</code>'s span for macros.</p>
<p>A span is effectively a text range relative to some item in a file with a given <code>SyntaxContext</code> (hygiene).</p>
<h2 id="cross-cutting-concerns"><a class="header" href="#cross-cutting-concerns">Cross-Cutting Concerns</a></h2>
<p>This sections talks about the things which are everywhere and nowhere in particular.</p>
<h3 id="stability-guarantees"><a class="header" href="#stability-guarantees">Stability Guarantees</a></h3>
<p>One of the reasons <code>wgsl-analyzer</code> moves relatively fast is that we do not introduce new stability guarantees.
Instead, as much as possible we leverage existing ones.</p>
<p>Examples:</p>
<ul>
<li>The <code>ide</code> API of <code>wgsl-analyzer</code> is explicitly unstable, but the LSP interface is stable, and here we just implement a stable API managed by someone else.</li>
<li><a href="https://www.w3.org/TR/WGSL">WGSL spec</a> is almost stable, and it is the primary input to <code>wgsl-analyzer</code>.</li>
</ul>
<p>Exceptions:</p>
<ul>
<li>We ship some LSP extensions, and we try to keep those somewhat stable.
Here, we need to work with a finite set of editor maintainers, so not providing rock-solid guarantees works.</li>
</ul>
<h3 id="code-generation"><a class="header" href="#code-generation">Code generation</a></h3>
<p>Some components in this repository are generated through automatic processes.
Generated code is updated automatically on <code>cargo test</code>.
Generated code is generally committed to the git repository.</p>
<p>In particular, we generate:</p>
<ul>
<li>
<p>Various sections of the manual:</p>
<ul>
<li>features</li>
<li>assists</li>
<li>config</li>
</ul>
</li>
<li>
<p>Documentation tests for assists</p>
</li>
</ul>
<p>See the <code>xtask\src\codegen\assists_doc_tests.rs</code> module for details.</p>
<h3 id="cancellation"><a class="header" href="#cancellation">Cancellation</a></h3>
<p>Suppose that the IDE is in the process of computing syntax highlighting when the user types <code>foo</code>.
What should happen?
<code>wgsl-analyzer</code>s answer is that the highlighting process should be cancelled - its results are now stale, and it also blocks modification of the inputs.</p>
<p>The salsa database maintains a global revision counter.
When applying a change, salsa bumps this counter and waits until all other threads using salsa finish.
If a thread does salsa-based computation and notices that the counter is incremented, it panics with a special value (see <code>Canceled::throw</code>).
That is, <code>wgsl-analyzer</code> requires unwinding.</p>
<p><code>ide</code> is the boundary where the panic is caught and transformed into a <code>Result&lt;T, Cancelled&gt;</code>.</p>
<h3 id="testing"><a class="header" href="#testing">Testing</a></h3>
<p>wgsl-analyzer has three interesting <a href="https://www.tedinski.com/2018/04/10/making-tests-a-positive-influence-on-design.html">system boundaries</a> to concentrate tests on.</p>
<p>The outermost boundary is the <code>wgsl-analyzer</code> crate, which defines an LSP interface in terms of stdio.
We do integration testing of this component, by feeding it with a stream of LSP requests and checking responses.
These tests are known as "heavy", because they interact with Cargo and read real files from disk.
For this reason, we try to avoid writing too many tests on this boundary: in a statically typed language, it is hard to make an error in the protocol itself if messages are themselves typed.
Heavy tests are only run when <code>RUN_SLOW_TESTS</code> env var is set.</p>
<p>The middle, and most important, boundary is <code>ide</code>.</p>
<!-- TODO check this -->
<p>Unlike <code>wgsl-analyzer</code>, which exposes API, <code>ide</code> uses WGSL API and is intended for use by various tools.
A typical test creates an <code>AnalysisHost</code>, calls some <code>Analysis</code> functions and compares the results against expectation.</p>
<p>The innermost and most elaborate boundary is <code>hir</code>.
It has a much richer vocabulary of types than <code>ide</code>, but the basic testing setup is the same: we create a database, run some queries, assert result.</p>
<p>For comparisons, we use the <code>expect</code> crate for snapshot testing.</p>
<p>To test various analysis corner cases and avoid forgetting about old tests, we use so-called marks.
See the <a href="https://docs.rs/cov-mark/latest/cov_mark">cov_mark</a> crate documentation for more.</p>
<p><strong>Architecture Invariant:</strong> <code>wgsl-analyzer</code> tests do not use <code>libcore</code> or <code>libstd</code>.
All required library code must be a part of the tests.
This ensures fast test execution.</p>
<p><strong>Architecture Invariant:</strong> tests are data driven and do not test the API.
Tests which directly call various API functions are a liability, because they make refactoring the API significantly more complicated.
Most of the tests look like this:</p>
<pre><code class="language-rust">#[track_caller]
fn check(input: &amp;str, expect: expect_test::Expect) {
    // The single place that actually exercises a particular API
}

#[test]
fn foo() {
    check("foo", expect![["bar"]]);
}

#[test]
fn spam() {
    check("spam", expect![["eggs"]]);
}
// ...and a hundred more tests that do not care about the specific API at all.</code></pre>
<p>To specify input data, we use a single string literal in a special format, which can describe a set of WGSL files.
See the <code>Fixture</code> its module for fixture examples and documentation.</p>
<p><strong>Architecture Invariant:</strong> all code invariants are tested by <code>#[test]</code> tests.
There is no additional checks in CI, formatting, and tidy tests are run with <code>cargo test</code>.</p>
<p><strong>Architecture Invariant:</strong> tests do not depend on any kind of external resources, they are perfectly reproducible.</p>
<h3 id="performance-testing"><a class="header" href="#performance-testing">Performance Testing</a></h3>
<p>TBA, take a look at the <code>metrics</code> xtask and <code>#[test] fn benchmark_xxx()</code> functions.</p>
<h3 id="error-handling"><a class="header" href="#error-handling">Error Handling</a></h3>
<p><strong>Architecture Invariant:</strong> core parts of <code>wgsl-analyzer</code> (<code>ide</code>/<code>hir</code>) do not interact with the outside world and thus cannot fail.
Only parts touching LSP are allowed to do IO.</p>
<p>Internals of <code>wgsl-analyzer</code> need to deal with broken code, but this is not an error condition.
wgsl-analyzer is robust: various analysis compute <code>(T, Vec&lt;Error&gt;)</code> rather than <code>Result&lt;T, Error&gt;</code>.</p>
<p><code>wgsl-analyzer</code> is a complex, long-running process.
It will always have bugs and panics;
to mitigate this, a panic in an isolated feature should not bring down the whole process.
Each LSP-request is protected by a <code>catch_unwind</code>.
We use <code>always</code> and <code>never</code> macros instead of <code>assert</code> to gracefully recover from impossible conditions.</p>
<h3 id="observability"><a class="header" href="#observability">Observability</a></h3>
<p><code>wgsl-analyzer</code> is a long-running process, so it is important to understand what happens inside.
We have several instruments for that.</p>
<p>The event loop that runs <code>wgsl-analyzer</code> is very explicit.
Rather than spawning futures or scheduling callbacks (open), the event loop accepts an <code>enum</code> of possible events (closed).
It is easy to see all the things that trigger <code>wgsl-analyzer</code> processing together with their performance.</p>
<p><code>wgsl-analyzer</code> includes a simple hierarchical profiler (<code>hprof</code>).
It is enabled with <code>WA_PROFILE='*&gt;50'</code> env var (log all (<code>*</code>) actions which take more than <code>50</code> ms) and produces output like:</p>
<!-- TODO replace with real example -->
<pre><code class="language-text">85ms - handle_completion
    68ms - import_on_the_fly
        67ms - import_assets::search_for_relative_paths
             0ms - crate_def_map:wait (804 calls)
             0ms - find_path (16 calls)
             2ms - find_similar_imports (1 calls)
             0ms - generic_params_query (334 calls)
            59ms - trait_solve_query (186 calls)
         0ms - Semantics::analyze_impl (1 calls)
         1ms - render_resolution (8 calls)
     0ms - Semantics::analyze_impl (5 calls)
</code></pre>
<p>This is cheap enough to enable in production.</p>
<p>Similarly, we save live object counting (<code>WA_COUNT=1</code>).
It is not cheap enough to enable in production, and this is a bug which should be fixed.</p>
<h3 id="configurability"><a class="header" href="#configurability">Configurability</a></h3>
<p><code>wgsl-analyzer</code> strives to be as configurable as possible while offering reasonable defaults where no configuration exists yet.
The rule of thumb is to enable most features by default unless they are buggy or degrade performance too much.
There will always be features that some people find more annoying than helpful, so giving the users the ability to tweak or disable these is a big part of offering a good user experience.
Enabling them by default is a matter of discoverability, as many users do not know about some features even though they are presented in the manual.
Mind the code-architecture gap: at the moment, we are using fewer feature flags than we really should.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../contributing/index.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../contributing/debugging.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../contributing/index.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../contributing/debugging.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>



        <script>
            window.playground_line_numbers = true;
        </script>

        <script>
            window.playground_copyable = true;
        </script>

        <script src="../ace.js"></script>
        <script src="../mode-rust.js"></script>
        <script src="../editor.js"></script>
        <script src="../theme-dawn.js"></script>
        <script src="../theme-tomorrow_night.js"></script>

        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
