<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Style - wgsl-analyzer</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">wgsl-analyzer</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/wgsl-analyzer/wgsl-analyzer/tree/master/docs/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/wgsl-analyzer/wgsl-analyzer/edit/master/docs/book/src/contributing/style.md" title="Suggest an edit" aria-label="Suggest an edit" rel="edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="style"><a class="header" href="#style">Style</a></h1>
<p>Our approach to "clean code" is two-fold:</p>
<ul>
<li>We generally do not block PRs on style changes.</li>
<li>At the same time, all code in <code>wgsl-analyzer</code> is constantly refactored.</li>
</ul>
<p>It is explicitly OK for a reviewer to flag only some nits in the PR, and then send a follow-up cleanup PR for things which are easier to explain by example, cc-ing the original author.
Sending small cleanup PRs (like renaming a single local variable) is encouraged.</p>
<p>When reviewing pull requests, prefer extending this document to leaving non-reusable comments on the pull request itself.</p>
<h2 id="general"><a class="header" href="#general">General</a></h2>
<h3 id="scale-of-changes"><a class="header" href="#scale-of-changes">Scale of Changes</a></h3>
<p>Everyone knows that it is better to send small &amp; focused pull requests.
The problem is, sometimes you <em>have</em> to, e.g., rewrite the whole compiler, and that just does not fit into a set of isolated PRs.</p>
<p>The main things to keep an eye on are the boundaries between various components.
There are three kinds of changes:</p>
<ol>
<li>
<p>Internals of a single component are changed.
Specifically, you do not change any <code>pub</code> items.
A good example here would be an addition of a new assist.</p>
</li>
<li>
<p>API of a component is expanded.
Specifically, you add a new <code>pub</code> function which was not there before.
A good example here would be the expansion of the assist API, for example, to implement lazy assists or assist groups.</p>
</li>
<li>
<p>A new dependency between components is introduced.
Specifically, you add a <code>pub use</code> re-export from another crate or you add a new line to the <code>[dependencies]</code> section of <code>Cargo.toml</code>.
A good example here would be adding reference search capability to the assists crate.</p>
</li>
</ol>
<p>For the first group, the change is generally merged as long as:</p>
<ul>
<li>it works for the happy case,</li>
<li>it has tests,</li>
<li>it does not panic for the unhappy case.</li>
</ul>
<p>For the second group, the change would be subjected to quite a bit of scrutiny and iteration.
The new API needs to be right (or at least easy to change later).
The actual implementation does not matter that much.
It is very important to minimize the number of changed lines of code for changes of the second kind.
Often, you start doing a change of the first kind, only to realize that you need to elevate to a change of the second kind.
In this case, we will probably ask you to split API changes into a separate PR.</p>
<p>Changes of the third group should be pretty rare, so we do not specify any specific process for them.
That said, adding an innocent-looking <code>pub use</code> is a very simple way to break encapsulation, keep an eye on it!</p>
<p>Note: if you enjoyed this abstract hand-waving about boundaries, you might appreciate <a href="https://www.tedinski.com/2018/02/06/system-boundaries.html">https://www.tedinski.com/2018/02/06/system-boundaries.html</a>.</p>
<h3 id="cratesio-dependencies"><a class="header" href="#cratesio-dependencies">Crates.io Dependencies</a></h3>
<p>We try to be very conservative with the usage of crates.io dependencies.
Do not use small "helper" crates (exception: <code>itertools</code> and <code>either</code> are allowed).
If there is some general reusable bit of code you need, consider adding it to the <code>stdx</code> crate.
A useful exercise is to read Cargo.lock and see if some <em>transitive</em> dependencies do not make sense for <code>wgsl-analyzer</code>.</p>
<p><strong>Rationale:</strong> keep compile times low, create ecosystem pressure for faster compiles, reduce the number of things which might break.</p>
<h3 id="commit-style"><a class="header" href="#commit-style">Commit Style</a></h3>
<p>We do not have specific rules around git history hygiene.
Maintaining clean git history is strongly encouraged, but not enforced.
Use rebase workflow, it is OK to rewrite history during the PR review process.
After you are happy with the state of the code, please use <a href="https://git-scm.com/book/en/v2/Git-Tools-Rewriting-History">interactive rebase</a> to squash fixup commits.</p>
<p>Avoid @mentioning people in commit messages and pull request descriptions (they are added to commit messages by bors).
Such messages create a lot of duplicate notification traffic during rebases.</p>
<p>If possible, write Pull Request titles and descriptions from the user's perspective:</p>
<pre><code class="language-text">## GOOD
Make goto definition work inside macros

## BAD
Use original span for FileId
</code></pre>
<p>This makes it easier to prepare a changelog.</p>
<p>If the change adds a new user-visible functionality, consider recording a GIF with <a href="https://github.com/phw/peek">peek</a> and pasting it into the PR description.</p>
<p>To make writing the release notes easier, you can mark a pull request as a feature, fix, internal change, or minor.
Minor changes are excluded from the release notes, while the other types are distributed in their corresponding sections.
There are two ways to mark this:</p>
<ul>
<li>use a <code>feat:</code>, <code>feature:</code>, <code>fix:</code>, <code>internal:</code>, or <code>minor:</code> prefix in the PR title</li>
<li>write <code>changelog [feature|fix|internal|skip] [description]</code> in a comment or in the PR description; the description is optional and will replace the title if included.</li>
</ul>
<p>These comments do not have to be added by the PR author.
Editing a comment or the PR description or title is also fine, as long as it happens before the release.</p>
<p><strong>Rationale:</strong> clean history is potentially useful, but rarely used.
But many users read changelogs.
Including a description and GIF suitable for the changelog means less work for the maintainers on the release day.</p>
<h3 id="clippy"><a class="header" href="#clippy">Clippy</a></h3>
<p>We use Clippy to improve the code, but if some lints annoy you, allow them in the <a href="../../Cargo.toml">Cargo.toml</a> [workspace.lints.clippy] section.</p>
<h2 id="code"><a class="header" href="#code">Code</a></h2>
<h3 id="minimal-tests"><a class="header" href="#minimal-tests">Minimal Tests</a></h3>
<p>Most tests in <code>wgsl-analyzer</code> start with a snippet of WESL code.
These snippets should be minimal.
If you copy-paste a snippet of real code into the tests, make sure to remove everything which could be removed.
It also makes sense to format snippets more compactly (for example, by placing enum definitions like <code>enum E { Foo, Bar }</code> on a single line), as long as they are still readable.
When using multiline fixtures, use unindented raw string literals:</p>
<pre><code class="language-rust">    #[test]
    fn inline_field_shorthand() {
        check_assist(
            inline_local_variable,
            r#"
struct S { foo: i32}
fn main() {
    let $0foo = 92;
    S { foo }
}
"#,
            r#"
struct S { foo: i32}
fn main() {
    S { foo: 92 }
}
"#,
        );
    }</code></pre>
<p><strong>Rationale:</strong></p>
<p>There are many benefits to this:</p>
<ul>
<li>less to read or to scroll past</li>
<li>easier to understand what exactly is tested</li>
<li>less stuff printed during printf-debugging</li>
<li>less time to run tests</li>
</ul>
<p>Formatting ensures that you can use your editor's "number of selected characters" feature to correlate offsets with tests' source code.</p>
<h3 id="marked-tests"><a class="header" href="#marked-tests">Marked Tests</a></h3>
<p>Use <a href="https://github.com/matklad/cov-mark"><code>cov_mark::hit! / cov_mark::check!</code></a> when testing specific conditions.
Do not place several marks into a single test or condition.
Do not reuse marks between several tests.</p>
<p><strong>Rationale:</strong> marks provide an easy way to find the canonical test for each bit of code.
This makes it much easier to understand.
More than one mark per test / code branch does not add significantly to understanding.</p>
<h3 id="should_panic"><a class="header" href="#should_panic"><code>#[should_panic]</code></a></h3>
<p>Do not use <code>#[should_panic]</code> tests.
Instead, explicitly check for <code>None</code>, <code>Err</code>, etc.</p>
<p><strong>Rationale:</strong> <code>#[should_panic]</code> is a tool for library authors to make sure that the API does not fail silently when misused.
<code>wgsl-analyzer</code> is not a library.
We do not need to test for API misuse, and we have to handle any user input without panics.
Panic messages in the logs from the <code>#[should_panic]</code> tests are confusing.</p>
<h3 id="ignore"><a class="header" href="#ignore"><code>#[ignore]</code></a></h3>
<p>Do not <code>#[ignore]</code> tests.
If the test currently does not work, assert the wrong behavior and add a fixme explaining why it is wrong.</p>
<p><strong>Rationale:</strong> noticing when the behavior is fixed, making sure that even the wrong behavior is acceptable (i.e., not a panic).</p>
<h3 id="function-preconditions"><a class="header" href="#function-preconditions">Function Preconditions</a></h3>
<p>Express function preconditions in types and force the caller to provide them (rather than checking in callee):</p>
<pre><code class="language-rust">// GOOD
fn frobnicate(walrus: Walrus) {
    ...
}

// BAD
fn frobnicate(walrus: Option&lt;Walrus&gt;) {
    let walrus = match walrus {
        Some(it) =&gt; it,
        None =&gt; return,
    };
    ...
}</code></pre>
<p><strong>Rationale:</strong> this makes control flow explicit at the call site.
Call-site has more context.
It often happens that the precondition falls out naturally or can be bubbled up higher in the stack.</p>
<p>Avoid splitting precondition check and precondition use across functions:</p>
<pre><code class="language-rust">// GOOD
fn main() {
    let string: &amp;str = ...;
    if let Some(contents) = string_literal_contents(string) {

    }
}

fn string_literal_contents(string: &amp;str) -&gt; Option&lt;&amp;str&gt; {
    if string.starts_with('"') &amp;&amp; string.ends_with('"') {
        Some(&amp;string[1..string.len() - 1])
    } else {
        None
    }
}

// BAD
fn main() {
    let string: &amp;str = ...;
    if is_string_literal(string) {
        let contents = &amp;string[1..string.len() - 1];
    }
}

fn is_string_literal(string: &amp;str) -&gt; bool {
    string.starts_with('"') &amp;&amp; string.ends_with('"')
}</code></pre>
<p>In the "Not as good" version, the precondition that <code>1</code> is a valid char boundary is checked in <code>is_string_literal</code> and used in <code>foo</code>.
In the "Good" version, the precondition check and usage are checked in the same block, and then encoded in the types.</p>
<p><strong>Rationale:</strong> non-local code properties degrade under change.</p>
<p>When checking a boolean precondition, prefer <code>if !invariant</code> to <code>if negated_invariant</code>:</p>
<pre><code class="language-rust">// GOOD
if !(index &lt; length) {
    return None;
}

// BAD
if index &gt;= length {
    return None;
}</code></pre>
<p><strong>Rationale:</strong> it is useful to see the invariant relied upon by the rest of the function clearly spelled out.</p>
<h3 id="control-flow"><a class="header" href="#control-flow">Control Flow</a></h3>
<p>As a special case of the previous rule, do not hide control flow inside functions, push it to the caller:</p>
<pre><code class="language-rust">// GOOD
if cond {
    foo();
}

fn foo() {
  ...
}

// BAD
bar();

fn bar() {
    if !cond {
        return;
    }
    ...
}</code></pre>
<h3 id="assertions"><a class="header" href="#assertions">Assertions</a></h3>
<p>Assert liberally.
Prefer <a href="https://docs.rs/always-assert/0.1.2/always_assert/macro.never.html"><code>stdx::never!</code></a> to standard <code>assert!</code>.</p>
<p><strong>Rationale:</strong> See <a href="https://github.com/wgsl-analyzer/wgsl-analyzer/blob/main/docs/book/src/contributing/architecture.md#error-handling">cross cutting concern: error handling</a>.</p>
<h3 id="getters--setters"><a class="header" href="#getters--setters">Getters &amp; Setters</a></h3>
<p>If a field can have any value without breaking invariants, make the field public.
Conversely, if there is an invariant, document it, enforce it in the "constructor" function, make the field private, and provide a getter.
Never provide setters.</p>
<p>Getters should return borrowed data:</p>
<pre><code class="language-rust">struct Person {
    // Invariant: never empty
    first_name: String,
    middle_name: Option&lt;String&gt;
}

// GOOD
impl Person {
    fn first_name(&amp;self) -&gt; &amp;str { self.first_name.as_str() }
    fn middle_name(&amp;self) -&gt; Option&lt;&amp;str&gt; { self.middle_name.as_ref() }
}

// BAD
impl Person {
    fn first_name(&amp;self) -&gt; String { self.first_name.clone() }
    fn middle_name(&amp;self) -&gt; &amp;Option&lt;String&gt; { &amp;self.middle_name }
}</code></pre>
<p><strong>Rationale:</strong> we do not provide public API.
It is cheaper to refactor than to pay getters rent.
Non-local code properties degrade under change.
Privacy makes invariant local.
Borrowed owned types (<code>&amp;String</code>) disclose irrelevant details about internal representation.
Irrelevant (neither right nor wrong) things obscure correctness.</p>
<h3 id="useless-types"><a class="header" href="#useless-types">Useless Types</a></h3>
<p>More generally, always prefer types on the left</p>
<pre><code class="language-rust">// GOOD      BAD
&amp;[T]         &amp;Vec&lt;T&gt;
&amp;str         &amp;String
Option&lt;&amp;T&gt;   &amp;Option&lt;T&gt;
&amp;Path        &amp;PathBuf</code></pre>
<p><strong>Rationale:</strong> types on the left are strictly more general.
Even when generality is not required, consistency is important.</p>
<h3 id="constructors"><a class="header" href="#constructors">Constructors</a></h3>
<p>Prefer <code>Default</code> to zero-argument <code>new</code> function.</p>
<pre><code class="language-rust">// GOOD
#[derive(Default)]
struct Foo {
    bar: Option&lt;Bar&gt;
}

// BAD
struct Foo {
    bar: Option&lt;Bar&gt;
}

impl Foo {
    fn new() -&gt; Foo {
        Foo { bar: None }
    }
}</code></pre>
<p>Prefer <code>Default</code> even if it has to be implemented manually.</p>
<p><strong>Rationale:</strong> less typing in the common case, uniformity.</p>
<p>Use <code>Vec::new</code> rather than <code>vec![]</code>.</p>
<p><strong>Rationale:</strong> uniformity, strength reduction.</p>
<p>Avoid using "dummy" states to implement a <code>Default</code>.
If a type does not have a sensible default, empty value, do not hide it.
Let the caller explicitly decide what the right initial state is.</p>
<h3 id="functions-over-objects"><a class="header" href="#functions-over-objects">Functions Over Objects</a></h3>
<p>Avoid creating "doer" objects.
That is, objects which are created only to execute a single action.</p>
<pre><code class="language-rust">// GOOD
do_thing(arg1, arg2);

// BAD
ThingDoer::new(arg1, arg2).do();</code></pre>
<p>Note that this concerns only outward API.
When implementing <code>do_thing</code>, it might be very useful to create a context object.</p>
<pre><code class="language-rust">pub fn do_thing(
  an_input: Argument1,
  another_input: Argument2,
) -&gt; Result {
    let mut context = Context { an_input, another_input };
    context.run()
}

struct Context {
    an_input: Argument1,
    another_input: Argument2,
}

impl Context {
    fn run(self) -&gt; Result {
        ...
    }
}</code></pre>
<p>The difference is that <code>Context</code> is an implementation detail here.</p>
<p>Sometimes a middle ground is acceptable if this can save some busywork:</p>
<pre><code class="language-rust">ThingDoer::do(an_input, another_input);

pub struct ThingDoer {
    an_input: Argument1,
    another_input: Argument2,
}

impl ThingDoer {
    pub fn do(
        an_input: Argument1,
        another_input: Argument2,
    ) -&gt; Result {
        ThingDoer { an_input, another_input }.run()
    }

    fn run(self) -&gt; Result {
        ...
    }
}</code></pre>
<p><strong>Rationale:</strong> not bothering the caller with irrelevant details, not mixing user API with implementor API.</p>
<h3 id="functions-with-many-parameters"><a class="header" href="#functions-with-many-parameters">Functions with many parameters</a></h3>
<p>Avoid creating functions with many optional or boolean parameters.
Introduce a <code>Config</code> struct instead.</p>
<pre><code class="language-rust">// GOOD
pub struct AnnotationConfig {
    pub binary_target: bool,
    pub annotate_runnables: bool,
    pub annotate_impls: bool,
}

pub fn annotations(
    db: &amp;RootDatabase,
    file_id: FileId,
    config: AnnotationConfig
) -&gt; Vec&lt;Annotation&gt; {
    ...
}

// BAD
pub fn annotations(
    db: &amp;RootDatabase,
    file_id: FileId,
    binary_target: bool,
    annotate_runnables: bool,
    annotate_impls: bool,
) -&gt; Vec&lt;Annotation&gt; {
    ...
}</code></pre>
<p><strong>Rationale:</strong> reducing churn.
If the function has many parameters, they most likely change frequently.
By packing them into a struct we protect all intermediary functions from changes.</p>
<p>Do not implement <code>Default</code> for the <code>Config</code> struct, the caller has more context to determine better defaults.
Do not store <code>Config</code> as a part of the <code>state</code>, pass it explicitly.
This gives more flexibility for the caller.</p>
<p>If there is variation not only in the input parameters, but in the return type as well, consider introducing a <code>Command</code> type.</p>
<pre><code class="language-rust">// MAYBE GOOD
pub struct Query {
    pub name: String,
    pub case_sensitive: bool,
}

impl Query {
    pub fn all(self) -&gt; Vec&lt;Item&gt; { ... }
    pub fn first(self) -&gt; Option&lt;Item&gt; { ... }
}

// MAYBE BAD
fn query_all(name: String, case_sensitive: bool) -&gt; Vec&lt;Item&gt; { ... }
fn query_first(name: String, case_sensitive: bool) -&gt; Option&lt;Item&gt; { ... }</code></pre>
<h3 id="prefer-separate-functions-over-parameters"><a class="header" href="#prefer-separate-functions-over-parameters">Prefer Separate Functions Over Parameters</a></h3>
<p>If a function has a <code>bool</code> or an <code>Option</code> parameter, and it is always called with <code>true</code>, <code>false</code>, <code>Some</code> and <code>None</code> literals, split the function in two.</p>
<pre><code class="language-rust">// GOOD
fn caller_a() {
    foo()
}

fn caller_b() {
    foo_with_bar(Bar::new())
}

fn foo() { ... }
fn foo_with_bar(bar: Bar) { ... }

// BAD
fn caller_a() {
    foo(None)
}

fn caller_b() {
    foo(Some(Bar::new()))
}

fn foo(bar: Option&lt;Bar&gt;) { ... }</code></pre>
<p><strong>Rationale:</strong> more often than not, such functions display "<code>false sharing</code>" -- they have additional <code>if</code> branching inside for two different cases.
Splitting the two different control flows into two functions simplifies each path, and remove cross-dependencies between the two paths.
If there is common code between <code>foo</code> and <code>foo_with_bar</code>, extract <em>that</em> into a common helper.</p>
<h3 id="appropriate-string-types"><a class="header" href="#appropriate-string-types">Appropriate String Types</a></h3>
<p>When interfacing with OS APIs, use <code>OsString</code>, even if the original source of data is utf-8 encoded.
<strong>Rationale:</strong> cleanly delineates the boundary when the data goes into the OS-land.</p>
<p>Use <code>AbsPathBuf</code> and <code>AbsPath</code> over <code>std::Path</code>.
<strong>Rationale:</strong> <code>wgsl-analyzer</code> is a long-lived process which handles several projects at the same time.
It is important not to leak cwd by accident.</p>
<h2 id="premature-pessimization"><a class="header" href="#premature-pessimization">Premature Pessimization</a></h2>
<h3 id="avoid-allocations"><a class="header" href="#avoid-allocations">Avoid Allocations</a></h3>
<p>Avoid writing code which is slower than it needs to be.
Do not allocate a <code>Vec</code> where an iterator would do, do not allocate strings needlessly.</p>
<pre><code class="language-rust">// GOOD
use itertools::Itertools;

let (first_word, second_word) = match text.split_ascii_whitespace().collect_tuple() {
    Some(it) =&gt; it,
    None =&gt; return,
}

// BAD
let words = text.split_ascii_whitespace().collect::&lt;Vec&lt;_&gt;&gt;();
if words.len() != 2 {
    return
}</code></pre>
<p><strong>Rationale:</strong> not allocating is almost always faster.</p>
<h3 id="push-allocations-to-the-call-site"><a class="header" href="#push-allocations-to-the-call-site">Push Allocations to the Call Site</a></h3>
<p>If allocation is inevitable, let the caller allocate the resource:</p>
<pre><code class="language-rust">// GOOD
fn frobnicate(string: String) {
    ...
}

// BAD
fn frobnicate(string: &amp;str) {
    let string = string.to_string();
    ...
}</code></pre>
<p><strong>Rationale:</strong> reveals the costs.
It is also more efficient when the caller already owns the allocation.</p>
<h3 id="collection-types"><a class="header" href="#collection-types">Collection Types</a></h3>
<p>Prefer <code>rustc_hash::FxHashMap</code> and <code>rustc_hash::FxHashSet</code> instead of the ones in <code>std::collections</code>.</p>
<p><strong>Rationale:</strong> they use a hasher that is significantly faster and using them consistently will reduce code size by some small amount.</p>
<h3 id="avoid-intermediate-collections"><a class="header" href="#avoid-intermediate-collections">Avoid Intermediate Collections</a></h3>
<p>When writing a recursive function to compute a set of things, use an accumulator parameter instead of returning a fresh collection.
The accumulator goes first in the list of arguments.</p>
<pre><code class="language-rust">// GOOD
pub fn reachable_nodes(node: Node) -&gt; FxHashSet&lt;Node&gt; {
    let mut result = FxHashSet::default();
    go(&amp;mut result, node);
    result
}
fn go(acc: &amp;mut FxHashSet&lt;Node&gt;, node: Node) {
    acc.insert(node);
    for n in node.neighbors() {
        go(acc, n);
    }
}

// BAD
pub fn reachable_nodes(node: Node) -&gt; FxHashSet&lt;Node&gt; {
    let mut result = FxHashSet::default();
    result.insert(node);
    for n in node.neighbors() {
        result.extend(reachable_nodes(n));
    }
    result
}</code></pre>
<p><strong>Rationale:</strong> re-use allocations, accumulator style is more concise for complex cases.</p>
<h3 id="avoid-monomorphization"><a class="header" href="#avoid-monomorphization">Avoid Monomorphization</a></h3>
<p>Avoid making a lot of code type parametric, <em>especially</em> on the boundaries between crates.</p>
<pre><code class="language-rust">// GOOD
fn frobnicate(function: impl FnMut()) {
    frobnicate_impl(&amp;mut function)
}
fn frobnicate_impl(function: &amp;mut dyn FnMut()) {
    // lots of code
}

// BAD
fn frobnicate(function: impl FnMut()) {
    // lots of code
}</code></pre>
<p>Avoid <code>AsRef</code> polymorphism, it pays back only for widely used libraries:</p>
<pre><code class="language-rust">// GOOD
fn frobnicate(foo: &amp;Path) {
}

// BAD
fn frobnicate(foo: impl AsRef&lt;Path&gt;) {
}</code></pre>
<p><strong>Rationale:</strong> Rust uses monomorphization to compile generic code, meaning that for each instantiation of a generic function with concrete types, the function is compiled afresh, <em>per crate</em>.
This allows for exceptionally good performance, but leads to increased compile times.
Runtime performance obeys the 80%/20% rule -- only a small fraction of code is hot.
Compile time <strong>does not</strong> obey this rule -- all code has to be compiled.</p>
<h2 id="code-style"><a class="header" href="#code-style">Code Style</a></h2>
<h3 id="order-of-imports"><a class="header" href="#order-of-imports">Order of Imports</a></h3>
<p>Separate import groups with blank lines.
Use one <code>use</code> per crate.</p>
<p>Module declarations come before the imports.
Order them in "suggested reading order" for a person new to the code base.</p>
<pre><code class="language-rust">mod x;
mod y;

// First std.
use std::{ ... }

// Second, external crates (both crates.io crates and other wgsl-analyzer crates).
use crate_foo::{ ... }
use crate_bar::{ ... }

// Then current crate.
use crate::{}

// Finally, parent and child modules, but prefer `use crate::`.
use super::{}

// Re-exports are treated as item definitions rather than imports, so they go
// after imports and modules. Use them sparingly.
pub use crate::x::Z;</code></pre>
<p><strong>Rationale:</strong> consistency.
Reading order is important for new contributors.
Grouping by crate allows spotting unwanted dependencies easier.</p>
<h3 id="import-style"><a class="header" href="#import-style">Import Style</a></h3>
<p>Qualify items from <code>hir</code> and <code>ast</code>.</p>
<pre><code class="language-rust">// GOOD
use syntax::ast;

fn frobnicate(func: hir::Function, r#struct: ast::Struct) {}

// BAD
use hir::Function;
use syntax::ast::Struct;

fn frobnicate(func: Function, r#struct: Struct) {}</code></pre>
<p><strong>Rationale:</strong> avoids name clashes, makes the layer clear at a glance.</p>
<p>When implementing traits from <code>std::fmt</code> or <code>std::ops</code>, import the module:</p>
<pre><code class="language-rust">// GOOD
use std::fmt;

impl fmt::Display for RenameError {
    fn fmt(&amp;self, formatter: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result { .. }
}

// BAD
impl std::fmt::Display for RenameError {
    fn fmt(&amp;self, formatter: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result { .. }
}

// BAD
use std::ops::Deref;

impl Deref for Widget {
    type Target = str;
    fn deref(&amp;self) -&gt; &amp;str { .. }
}</code></pre>
<p><strong>Rationale:</strong> overall, less typing.
Makes it clear that a trait is implemented, rather than used.</p>
<p>Avoid local <code>use MyEnum::*</code> imports.
<strong>Rationale:</strong> consistency.</p>
<p>Prefer <code>use crate::foo::bar</code> to <code>use super::bar</code> or <code>use self::bar::baz</code>.
<strong>Rationale:</strong> consistency, this is the style which works in all cases.</p>
<p>By default, avoid re-exports.
<strong>Rationale:</strong> for non-library code, re-exports introduce two ways to use something and allow for inconsistency.</p>
<h3 id="order-of-items"><a class="header" href="#order-of-items">Order of Items</a></h3>
<p>Optimize for the reader who sees the file for the first time, and wants to get a general idea about what is going on.
People read things from top to bottom, so place most important things first.</p>
<p>Specifically, if all items except one are private, always put the non-private item on top.</p>
<pre><code class="language-rust">// GOOD
pub(crate) fn frobnicate() {
    Helper::act()
}

#[derive(Default)]
struct Helper { stuff: i32 }

impl Helper {
    fn act(&amp;self) {

    }
}

// BAD
#[derive(Default)]
struct Helper { stuff: i32 }

pub(crate) fn frobnicate() {
    Helper::act()
}

impl Helper {
    fn act(&amp;self) {

    }
}</code></pre>
<p>If there is a mixture of private and public items, put public items first.</p>
<p>Put <code>struct</code>s and <code>enum</code>s first, functions and impls last. Order type declarations in top-down manner.</p>
<pre><code class="language-rust">// GOOD
struct Parent {
    children: Vec&lt;Child&gt;
}

struct Child;

impl Parent {
}

impl Child {
}

// BAD
struct Child;

impl Child {
}

struct Parent {
    children: Vec&lt;Child&gt;
}

impl Parent {
}</code></pre>
<p><strong>Rationale:</strong> easier to get the sense of the API by visually scanning the file.
If function bodies are folded in the editor, the source code should read as documentation for the public API.</p>
<h3 id="context-parameters"><a class="header" href="#context-parameters">Context Parameters</a></h3>
<p>Some parameters are threaded unchanged through many function calls.
They determine the "context" of the operation.
Pass such parameters first, not last.
If there are several context parameters, consider packing them into a <code>struct Ctx</code> and passing it as <code>&amp;self</code>.</p>
<pre><code class="language-rust">// GOOD
fn dfs(graph: &amp;Graph, v: Vertex) -&gt; usize {
    let mut visited = FxHashSet::default();
    return go(graph, &amp;mut visited, v);

    fn go(graph: &amp;Graph, visited: &amp;mut FxHashSet&lt;Vertex&gt;, v: usize) -&gt; usize {
        ...
    }
}

// BAD
fn dfs(v: Vertex, graph: &amp;Graph) -&gt; usize {
    fn go(v: usize, graph: &amp;Graph, visited: &amp;mut FxHashSet&lt;Vertex&gt;) -&gt; usize {
        ...
    }

    let mut visited = FxHashSet::default();
    go(v, graph, &amp;mut visited)
}</code></pre>
<p><strong>Rationale:</strong> consistency.
Context-first works better when non-context parameter is a lambda.</p>
<h3 id="variable-naming"><a class="header" href="#variable-naming">Variable Naming</a></h3>
<p><a href="https://www.youtube.com/watch?v=-J3wNP6u5YU">https://www.youtube.com/watch?v=-J3wNP6u5YU</a></p>
<p>Use boring and long names for local variables (yay code completion).
The default name is a lowercased name of the type: <code>global_state: GlobalState</code>.
Avoid all acronyms and contractions unless it is overwhelmingly appropriate.
Use American spelling (color, behavior).</p>
<p>Many names in <code>wgsl-analyzer</code> conflict with keywords.
We use <code>r#ident</code> syntax where necessary.</p>
<pre><code class="language-text">crate  -&gt; r#crate
enum   -&gt; r#enum
fn     -&gt; r#fn
impl   -&gt; r#impl
mod    -&gt; r#mod
struct -&gt; r#struct
trait  -&gt; r#trait
type   -&gt; r#type
</code></pre>
<p><strong>Rationale:</strong> idiomatic, clarity.</p>
<h3 id="error-handling-trivia"><a class="header" href="#error-handling-trivia">Error Handling Trivia</a></h3>
<p>Prefer <code>anyhow::Result</code> over <code>Result</code>.</p>
<p><strong>Rationale:</strong> makes it immediately clear what result that is.</p>
<p>Prefer <code>anyhow::format_err!</code> over <code>anyhow::anyhow</code>.</p>
<p><strong>Rationale:</strong> consistent, boring, avoids stuttering.</p>
<p><a href="https://doc.rust-lang.org/stable/std/error/trait.Error.html">Error messages are typically concise lowercase sentences without trailing punctuation.</a></p>
<h3 id="early-returns"><a class="header" href="#early-returns">Early Returns</a></h3>
<p><em>Do</em> use early returns</p>
<pre><code class="language-rust">// GOOD
fn foo() -&gt; Option&lt;Bar&gt; {
    if !condition() {
        return None;
    }

    Some(...)
}

// BAD
fn foo() -&gt; Option&lt;Bar&gt; {
    if condition() {
        Some(...)
    } else {
        None
    }
}</code></pre>
<p><strong>Rationale:</strong> reduce cognitive stack usage.</p>
<p>Use <code>return Err(error)</code> to "throw" an error:</p>
<pre><code class="language-rust">// GOOD
fn foo() -&gt; Result&lt;(), ()&gt; {
    if condition {
        return Err(());
    }
    Ok(())
}

// BAD
fn foo() -&gt; Result&lt;(), ()&gt; {
    if condition {
        Err(())?;
    }
    Ok(())
}</code></pre>
<p><strong>Rationale:</strong> <code>return</code> has type <code>!</code>, which allows the compiler to flag dead
code (<code>Err(...)?</code> is of unconstrained generic type <code>T</code>).</p>
<h3 id="comparisons"><a class="header" href="#comparisons">Comparisons</a></h3>
<p>When doing multiple comparisons use <code>&lt;</code>/<code>&lt;=</code>, avoid <code>&gt;</code>/<code>&gt;=</code>.</p>
<pre><code class="language-rust">// GOOD
assert!(lo &lt;= x &amp;&amp; x &lt;= hi);
assert!(r1 &lt; l2 || r2 &lt; l1);
assert!(x &lt; y);
assert!(0 &lt; x);

// BAD
assert!(x &gt;= lo &amp;&amp; x &lt;= hi);
assert!(r1 &lt; l2 || l1 &gt; r2);
assert!(y &gt; x);
assert!(x &gt; 0);</code></pre>
<p><strong>Rationale:</strong> Less-then comparisons are more intuitive; they correspond spatially to <a href="https://en.wikipedia.org/wiki/Real_line">real line</a>.</p>
<h3 id="if-let"><a class="header" href="#if-let">if-let</a></h3>
<p>Avoid <code>if let ... { } else { }</code> construct; prefer <code>match</code>.</p>
<pre><code class="language-rust">// GOOD
match context.expected_type.as_ref() {
    Some(expected_type) =&gt; completion_ty == expected_type &amp;&amp; !expected_type.is_unit(),
    None =&gt; false,
}

// BAD
if let Some(expected_type) = context.expected_type.as_ref() {
    completion_ty == expected_type &amp;&amp; !expected_type.is_unit()
} else {
    false
}</code></pre>
<p><strong>Rationale:</strong> <code>match</code> is almost always more compact.
The <code>else</code> branch can get a more precise pattern: <code>None</code> or <code>Err(_)</code> instead of <code>_</code>.</p>
<h3 id="match-ergonomics"><a class="header" href="#match-ergonomics">Match Ergonomics</a></h3>
<p>Do not use the <code>ref</code> keyword.</p>
<p><strong>Rationale:</strong> consistency &amp; simplicity.
<code>ref</code> was required before <a href="https://github.com/rust-lang/rfcs/blob/master/text/2005-match-ergonomics.md">match ergonomics</a>.
Today, it is redundant.
Between <code>ref</code> and mach ergonomics, the latter is more ergonomic in most cases, and is simpler (does not require a keyword).</p>
<h3 id="empty-match-arms"><a class="header" href="#empty-match-arms">Empty Match Arms</a></h3>
<p>Use <code>=&gt; (),</code> when a match arm is intentionally empty:</p>
<pre><code class="language-rust">// GOOD
match result {
    Ok(_) =&gt; (),
    Err(error) =&gt; error!("{}", error),
}

// BAD
match result {
    Ok(_) =&gt; {}
    Err(error) =&gt; error!("{}", error),
}</code></pre>
<p><strong>Rationale:</strong> consistency.</p>
<h3 id="functional-combinators"><a class="header" href="#functional-combinators">Functional Combinators</a></h3>
<p>Use high order monadic combinators like <code>map</code>, <code>then</code> when they are a natural choice; do not bend the code to fit into some combinator.
If writing a chain of combinators creates friction, replace them with control flow constructs: <code>for</code>, <code>if</code>, <code>match</code>.
Mostly avoid <code>bool::then</code> and <code>Option::filter</code>.</p>
<pre><code class="language-rust">// GOOD
if !x.cond() {
    return None;
}
Some(x)

// BAD
Some(x).filter(|it| it.cond())</code></pre>
<p>This rule is more "soft" then others, and boils down mostly to taste.
The guiding principle behind this rule is that code should be dense in computation, and sparse in the number of expressions per line.
The second example contains <em>less</em> computation -- the <code>filter</code> function is an indirection for <code>if</code>, it does not do any useful work by itself.
At the same time, it is more crowded -- it takes more time to visually scan it.</p>
<p><strong>Rationale:</strong> consistency, playing to languages' strengths.
Rust has first-class support for imperative control flow constructs
like <code>for</code> and <code>if</code>, while functions are less first-class due to lack
of universal function type, currying, and non-first-class effects (<code>?</code>, <code>.await</code>).</p>
<h3 id="turbofish"><a class="header" href="#turbofish">Turbofish</a></h3>
<p>Prefer type ascription over the turbofish.
When ascribing types, avoid <code>_</code></p>
<pre><code class="language-rust">// GOOD
let mutable: Vec&lt;T&gt; = old.into_iter().map(|it| builder.make_mut(it)).collect();

// BAD
let mutable: Vec&lt;_&gt; = old.into_iter().map(|it| builder.make_mut(it)).collect();

// BAD
let mutable = old.into_iter().map(|it| builder.make_mut(it)).collect::&lt;Vec&lt;_&gt;&gt;();</code></pre>
<p><strong>Rationale:</strong> consistency, readability.
If compiler struggles to infer the type, the human would as well.
Having the result type specified up-front helps with understanding what the chain of iterator methods is doing.</p>
<h3 id="helper-functions"><a class="header" href="#helper-functions">Helper Functions</a></h3>
<p>Avoid creating single-use helper functions:</p>
<pre><code class="language-rust">// GOOD
let buf = {
    let mut buf = get_empty_buf(&amp;mut arena);
    buf.add_item(item);
    buf
};

// BAD
let buf = prepare_buf(&amp;mut arena, item);

...

fn prepare_buf(arena: &amp;mut Arena, item: Item) -&gt; ItemBuf {
    let mut result = get_empty_buf(&amp;mut arena);
    result.add_item(item);
    result
}</code></pre>
<p>Exception: if you want to make use of <code>return</code> or <code>?</code>.</p>
<p><strong>Rationale:</strong> single-use functions change frequently, adding or removing parameters adds churn.
A block serves just as well to delineate a bit of logic, but has access to all the context.
Re-using originally single-purpose function often leads to bad coupling.</p>
<h3 id="local-helper-functions"><a class="header" href="#local-helper-functions">Local Helper Functions</a></h3>
<p>Put nested helper functions at the end of the enclosing functions
(this requires using return statement).
Do not nest more than one level deep.</p>
<pre><code class="language-rust">// GOOD
fn dfs(graph: &amp;Graph, v: Vertex) -&gt; usize {
    let mut visited = FxHashSet::default();
    return go(graph, &amp;mut visited, v);

    fn go(graph: &amp;Graph, visited: &amp;mut FxHashSet&lt;Vertex&gt;, v: usize) -&gt; usize {
        ...
    }
}

// BAD
fn dfs(graph: &amp;Graph, v: Vertex) -&gt; usize {
    fn go(graph: &amp;Graph, visited: &amp;mut FxHashSet&lt;Vertex&gt;, v: usize) -&gt; usize {
        ...
    }

    let mut visited = FxHashSet::default();
    go(graph, &amp;mut visited, v)
}</code></pre>
<p><strong>Rationale:</strong> consistency, improved top-down readability.</p>
<h3 id="helper-variables"><a class="header" href="#helper-variables">Helper Variables</a></h3>
<p>Introduce helper variables freely, especially for multiline conditions:</p>
<pre><code class="language-rust">// GOOD
let wgslfmt_not_installed =
    captured_stderr.contains("not installed") || captured_stderr.contains("not available");

match output.status.code() {
    Some(1) if !wgslfmt_not_installed =&gt; Ok(None),
    _ =&gt; Err(format_err!("wgslfmt failed:\n{}", captured_stderr)),
};

// BAD
match output.status.code() {
    Some(1)
        if !captured_stderr.contains("not installed")
           &amp;&amp; !captured_stderr.contains("not available") =&gt; Ok(None),
    _ =&gt; Err(format_err!("wgslfmt failed:\n{}", captured_stderr)),
};</code></pre>
<p><strong>Rationale:</strong> Like blocks, single-use variables are a cognitively cheap abstraction, as they have access to all the context.
Extra variables help during debugging, they make it easy to print/view important intermediate results.
Giving a name to a condition inside an <code>if</code> expression often improves clarity and leads to nicely formatted code.</p>
<h3 id="token-names"><a class="header" href="#token-names">Token names</a></h3>
<p>Use <code>T![foo]</code> instead of <code>SyntaxKind::FOO_KW</code>.</p>
<pre><code class="language-rust">// GOOD
match p.current() {
    T![true] | T![false] =&gt; true,
    _ =&gt; false,
}

// BAD
match p.current() {
    SyntaxKind::TRUE_KW | SyntaxKind::FALSE_KW =&gt; true,
    _ =&gt; false,
}</code></pre>
<p><strong>Rationale:</strong> The macro uses the familiar Rust syntax, avoiding ambiguities like "is this a brace or bracket?".</p>
<h3 id="documentation"><a class="header" href="#documentation">Documentation</a></h3>
<p>Style inline code comments as proper sentences.
Start with a capital letter, end with a dot.</p>
<pre><code class="language-rust">// GOOD

// Only simple single segment paths are allowed.
MergeBehavior::Last =&gt; {
    tree.use_tree_list().is_none() &amp;&amp; tree.path().map(path_len) &lt;= Some(1)
}

// BAD

// only simple single segment paths are allowed
MergeBehavior::Last =&gt; {
    tree.use_tree_list().is_none() &amp;&amp; tree.path().map(path_len) &lt;= Some(1)
}</code></pre>
<p><strong>Rationale:</strong> writing a sentence (or maybe even a paragraph) rather just "a comment" creates a more appropriate frame of mind.
It tricks you into writing down more of the context you keep in your head while coding.</p>
<p>For <code>.md</code> files, prefer a sentence-per-line format, do not wrap lines.
If the line is too long, you might want to split the sentence in two.</p>
<p><strong>Rationale:</strong> much easier to edit the text and read the diff, see <a href="https://asciidoctor.org/docs/asciidoc-recommended-practices/#one-sentence-per-line">this link</a>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../contributing/setup.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../contributing/syntax.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../contributing/setup.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../contributing/syntax.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>



        <script>
            window.playground_line_numbers = true;
        </script>

        <script>
            window.playground_copyable = true;
        </script>

        <script src="../ace.js"></script>
        <script src="../mode-rust.js"></script>
        <script src="../editor.js"></script>
        <script src="../theme-dawn.js"></script>
        <script src="../theme-tomorrow_night.js"></script>

        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
